<!--
da aggiungere:
- separa html e js, importa js
- sistemare css e colori
- libreria graphology in /lib/
- togliere webcsv, mettere comparisons-tool (cambiare nome a totale.csv)
- aggiungere menu e navigazione (download immagini)
- aggiungere edges curvi
- label sopra, aggiungere nomi corti (da proj. description)
- posizionamento labels
- far generare una legenda quando si scarica immagine
- aggiungere toggle per dimensionamento nodo a dimensioni pagina libro
- offprint/textured effect
- rifai la visualizzazione senza ai
- linkdinamico da index.html che genera dinamicamente link a tutte le visualizzazioni
-->

<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>TRAMA: Comparison map (ForceAtlas2)</title>
        <link
                rel="icon"
                type="image/png"
                href="../assets/favicon-96x96.png?"
                sizes="96x96"/>
        <link rel="icon" type="image/svg+xml" href="../assets/favicon.svg?" />
        <link rel="shortcut icon" href="../assets/favicon.ico?" />

        <link rel="stylesheet" href="../styles/style.css" />
        <link rel="stylesheet" href="../styles/modal.css" />
        <link rel="stylesheet" href="../styles/menu.css" />
        <style>
            html, body {
                height: 100%;
                margin: 0;
                padding: 0;
                overflow: hidden; /* Prevent scrollbars on the main page */
                background-color: #f7f7f7;
            }

            body {
                display: flex;
                flex-direction: row; /* Force side-by-side layout */
                font-family: 'Inter', sans-serif;
            }

            div {
                max-width: none;
                margin: 0;
                padding: 0; 
            }

            /* The controls panel is positioned on top of the visualization */
            #controls {
                position: absolute;
                top: 20px;
                left: 20px;
                width: 200px; /* Give it a comfortable fixed width */
                height: auto;  /* This makes the height 'hug' the content */
                padding: 15px;
                display: flex;
                flex-direction: column; 
                gap: 15px; 
                z-index: 10; /* Ensure it's on top */
                max-height: calc(100vh - 40px); /* Prevent it from getting taller than the screen */
                overflow: hidden;
                align-items: start;
            }

            #controls h3 {
                margin: 0;
                font-size: 1.2em;
                font-weight: bold;
                text-align: center;
            }
            
            .control-group {
              display: flex;
              flex-direction: column;
              width: 100%;
              gap: 8px;
            }
            
            .control-group label {
              text-transform: uppercase;
              font-size: 0.9em;
              color: black;
            }

            .control-group select {
                position: relative;
                width: fit-content;
                max-width: calc(200px - 15px);
                padding: 4px;
                border-radius: 8px;
            }

            #controls hr {
                border: 0.5px solid black;
                width: 100%;
                margin-top: 5px;
                margin-bottom: 5px;
            }


            #controls #remove-property {
                background-color: white;
                color: #783ce6;
                border: 0.5px solid #783ce6;
                font-weight: 500;
            }
            
            #controls button {
                border: 0.5px solid #783ce6;
                padding: 8px;
                width: calc(100% - 15px);
                border-radius: 8px;
                background-color: #783ce6;
                color: #fff;
                font-weight: 600;
            }

            #controls button:hover, #controls #remove-property:hover {
                background-color: #a682e8;
                border: 0.5px solid #783ce6;
                color: #fff;
            }

            #controls button:active, #controls #remove-property:active {
                background-color: #f2a900;
                border-color: #b17c03;
            }

            #controls button:disabled {
                background-color: #ccc;
                border-color: #adadad;
                cursor: not-allowed;
            }

            #node-viz {
                flex-grow: 1; /* Allow the viz div to fill all remaining horizontal space */
                cursor: grab;
                overflow: hidden; /* Crucially, prevent the SVG from overflowing its container */
                position: relative;
                width: 100%;
                height: 100vh;
            }
            
            #node-viz:active {
                cursor: grabbing;
            }

            #node-viz svg {
                display: block;
                width: 100%;
                height: 100%;
            }

            #dynamic-properties .control-group {
                margin-top: 10px;
            }

        </style>
        <script src="../lib/d3.js"></script>
        <script src="../lib/d3-delaunay.js"></script>
        <script src="../lib/d3-bboxCollide.min.js"></script>
        <!-- Graphology -->
        <script src="https://unpkg.com/graphology@0.25.4/dist/graphology.umd.js"></script>
        <script src="../scripts/manageFonts.js"></script>
        <script src="../scripts/createEcosystemMap.js"></script>
    </head>
    <body>
        <div id="controls">
            <h3>Data Comparison</h3>
            <div class="control-group">
                <label for="property-1">Order by</label>
                <select id="property-1"></select>
                <select id="filter-central"></select>
            </div>

            <div id="dynamic-properties"></div>

            <div class="control-group">
                <!--<label for="property-2">and</label>
                <select id="property-2"></select>
                <label for="property-2">Compare with</label>-->
                <button id="add-property">Add Property</button>
                <button id="remove-property" style="display: none;">Remove Property</button>
            </div>
            <button id="update">Update Visualization</button> <!-- aggiungi warning o rendilo unavaible-->
            
        </div>
        </div>
        <div id="node-viz"></div>
        
        <!-- ForceAtlas2 Implementation -->
        <script>
            /**
             * Animated ForceAtlas2 layout implementation
             * Based on the algorithm from: https://journals.plos.org/plosone/article?id=10.1371/journal.pone.0098679
             */
            const ForceAtlas2 = {
                create: function(graph, options = {}) {
                    const settings = options.settings || {};
                    
                    // Default settings - tuned for better spacing
                    const config = {
                        linLogMode: settings.linLogMode !== undefined ? settings.linLogMode : false,
                        outboundAttractionDistribution: settings.outboundAttractionDistribution !== undefined ? settings.outboundAttractionDistribution : false,
                        adjustSizes: settings.adjustSizes !== undefined ? settings.adjustSizes : false,
                        edgeWeightInfluence: settings.edgeWeightInfluence !== undefined ? settings.edgeWeightInfluence : 0.1,
                        scalingRatio: settings.scalingRatio !== undefined ? settings.scalingRatio : 50,
                        strongGravityMode: settings.strongGravityMode !== undefined ? settings.strongGravityMode : false,
                        gravity: settings.gravity !== undefined ? settings.gravity : 0.1,
                        slowDown: settings.slowDown !== undefined ? settings.slowDown : 1,
                        barnesHutOptimize: settings.barnesHutOptimize !== undefined ? settings.barnesHutOptimize : false,
                        barnesHutTheta: settings.barnesHutTheta !== undefined ? settings.barnesHutTheta : 0.5
                    };
                    
                    // Get all nodes
                    const nodeMap = new Map();
                    graph.forEachNode((node, attributes) => {
                        nodeMap.set(node, {
                            id: node,
                            x: attributes.x || 0,
                            y: attributes.y || 0,
                            mass: graph.degree(node) + 1,
                            size: attributes.r || 1,
                            dx: 0,
                            dy: 0,
                            old_dx: 0,
                            old_dy: 0,
                            fx: null,
                            fy: null
                        });
                    });
                    
                    return {
                        graph: graph,
                        config: config,
                        nodeMap: nodeMap,
                        running: false,
                        alpha: 1,
                        _alphaTarget: 0,
                        _alphaDecay: 0.0228,
                        
                        step: function() {
                            const nodes = Array.from(this.nodeMap.values());
                            
                            // Reset forces
                            nodes.forEach(n => {
                                n.dx = 0;
                                n.dy = 0;
                            });
                            
                            // Repulsion forces (all pairs)
                            for (let i = 0; i < nodes.length; i++) {
                                for (let j = i + 1; j < nodes.length; j++) {
                                    const n1 = nodes[i];
                                    const n2 = nodes[j];
                                    
                                    const dx = n1.x - n2.x;
                                    const dy = n1.y - n2.y;
                                    const distance = Math.sqrt(dx * dx + dy * dy) || 0.01;
                                    
                                    // Calculate repulsion
                                    let repulsion = this.config.scalingRatio * (n1.mass * n2.mass) / distance;
                                    
                                    if (this.config.adjustSizes) {
                                        repulsion /= (distance / (n1.size + n2.size));
                                    }
                                    
                                    n1.dx += (dx / distance) * repulsion;
                                    n1.dy += (dy / distance) * repulsion;
                                    n2.dx -= (dx / distance) * repulsion;
                                    n2.dy -= (dy / distance) * repulsion;
                                }
                            }
                            
                            // Attraction forces (edges)
                            this.graph.forEachEdge((edge, attributes, source, target) => {
                                const n1 = this.nodeMap.get(source);
                                const n2 = this.nodeMap.get(target);
                                
                                if (!n1 || !n2) return;
                                
                                const dx = n1.x - n2.x;
                                const dy = n1.y - n2.y;
                                const distance = Math.sqrt(dx * dx + dy * dy) || 0.01;
                                
                                let attraction;
                                if (this.config.linLogMode) {
                                    attraction = Math.log(1 + distance);
                                } else {
                                    attraction = distance;
                                }
                                
                                attraction *= this.config.edgeWeightInfluence;
                                
                                if (this.config.outboundAttractionDistribution) {
                                    attraction /= n1.mass;
                                }
                                
                                n1.dx -= (dx / distance) * attraction;
                                n1.dy -= (dy / distance) * attraction;
                                n2.dx += (dx / distance) * attraction;
                                n2.dy += (dy / distance) * attraction;
                            });
                            
                            // Gravity
                            nodes.forEach(n => {
                                const distance = Math.sqrt(n.x * n.x + n.y * n.y) || 0.01;
                                const gf = this.config.gravity * n.mass;
                                
                                if (this.config.strongGravityMode) {
                                    n.dx -= gf * n.x;
                                    n.dy -= gf * n.y;
                                } else {
                                    n.dx -= gf * (n.x / distance);
                                    n.dy -= gf * (n.y / distance);
                                }
                            });
                            
                            // Apply forces
                            nodes.forEach(n => {
                                const swinging = Math.sqrt((n.dx - n.old_dx) ** 2 + (n.dy - n.old_dy) ** 2);
                                const traction = Math.sqrt((n.dx + n.old_dx) ** 2 + (n.dy + n.old_dy) ** 2) / 2;
                                const factor = this.config.slowDown / (1 + Math.sqrt(swinging));
                                
                                // Only update position if not fixed (for dragging)
                                if (n.fx == null) {
                                    n.x += n.dx * factor;
                                } else {
                                    n.x = n.fx;
                                }
                                
                                if (n.fy == null) {
                                    n.y += n.dy * factor;
                                } else {
                                    n.y = n.fy;
                                }
                                
                                n.old_dx = n.dx;
                                n.old_dy = n.dy;
                            });
                            
                            // Update graph with new positions
                            nodes.forEach(n => {
                                this.graph.setNodeAttribute(n.id, 'x', n.x);
                                this.graph.setNodeAttribute(n.id, 'y', n.y);
                            });
                            
                            // Update alpha
                            this.alpha += (this._alphaTarget - this.alpha) * this._alphaDecay;
                            
                            return this;
                        },
                        
                        tick: function() {
                            return this.step();
                        },
                        
                        start: function() {
                            this.running = true;
                            this.alpha = 1;
                            return this;
                        },
                        
                        stop: function() {
                            this.running = false;
                            return this;
                        },
                        
                        restart: function() {
                            this.alpha = 1;
                            this.running = true;
                            return this;
                        },
                        
                        alphaTarget: function(target) {
                            if (target === undefined) return this._alphaTarget;
                            this._alphaTarget = target;
                            return this;
                        },
                        
                        getNodePosition: function(nodeId) {
                            const node = this.nodeMap.get(nodeId);
                            return node ? { x: node.x, y: node.y } : null;
                        }
                    };
                }
            };
        </script>
        
        <script type="module">

            ////////////COLORS////////////
            const COLOR_BACKGROUND = "#f7f7f7";
            const COLOR_PURPLE = "#783ce6";

            const COLOR_REPO_MAIN = "#a682e8";
            const COLOR_PROJECT = "#64d6d3"; // "#b2faf8"
            const COLOR_OWNER = "#f2a900";
            const COLOR_CONTRIBUTOR = "#ea9df5";

            /** check this colors**/
            const a = "#FF6347";
            const b = "#4682B4";
            const c = "#32CD32";

            const secondaryColors = [COLOR_OWNER, COLOR_CONTRIBUTOR, a, b, c];

            const COLOR_LINK = "#e8e8e8";
            const COLOR_TEXT = "#4d4950";

            const svg = d3.select("#node-viz")
                .append("svg")
                .attr("width", "100%")
                .attr("height", "100%");
            
            // Add background rect for zoom/pan interaction
            svg.append("rect")
                .attr("width", "100%")
                .attr("height", "100%")
                .attr("fill", "#f7f7f7");
            
            const container = svg.append("g");

            const zoom = d3.zoom()
                .scaleExtent([0.1, 8])
                .on("zoom", zoomed);

            function zoomed(event) {
                container.attr("transform", event.transform);
            }

            svg.call(zoom);

            // — Helper to parse array-like strings robustly —
            function parseArrayField(str) {
                try {
                    // replace single quotes with double quotes to conform to JSON
                    return JSON.parse(str.replace(/'/g, '"'));
                } catch (e) {
                    console.warn("Parsing failed for:", str); //aggiungi poi a mano
                    return [];
                }
            };

            //detect and display a message when no data is available
            function displayCanvasMessage(message) {
                const container_element = document.getElementById('node-viz');
                const width = container_element.clientWidth || 800;
                const height = container_element.clientHeight || 800;
                
                container.html(''); // Clear previous visualization
                container.append("text")
                    .attr("x", width / 2)
                    .attr("y", height / 2)
                    .attr("text-anchor", "middle")
                    .style("font-size", "16px")
                    .text(message)
                    .style("align-items", "middle")
                    .style("fill", "#d4d4d4")
                    .style("justify-content", "center");
            }

            //dynamic csv web link --> in futuro cambia dinamicamente a seconda del filtro di associazioni
            const webcsv = 'https://docs.google.com/spreadsheets/d/e/2PACX-1vTQLeh9W9SjUZ6DDhTqwSTpe_GDRwI_SytVkpKinC03EHTkIzNwQGi9WTNXQNvAienKox-nRVoXax6q/pub?gid=2021488932&single=true&output=csv';

            d3.csv(webcsv).then(data => {
                console.log(data);

                let CENTRAL_NODE; //could use it as a filter
                let selectedProperty1; // to store the first property selected
                //let selectedProperty2; // to store the second property selected
                let selectedSecondaryProperties = []; // dynamic properties to compare


                /*create the list for the selects*/
                const properties = [
                    //"Title", //dubbio, farebbe una visualizzazione alternativa (si può provare)
                    "Select one",
                    "Primary Objective",
                    "Secondary Objectives",
                    "Beneficiaries",
                    "Creative Approach",
                    "Financial Resources",
                    "Business Model",
                    "Human Resources",
                    "Entity Types",
                    "ICH Domain",
                    "ICH Elements",
                    "Data Type",
                    "Capturing Technologies",
                    "Representation Technologies",
                    "Dissemination Technologies",
                    "Fruition Output"
                ]; //handpicked headers

                const second_properties = [ //all headers
                    "Select one",
                    "Primary Objective",
                    "Secondary Objectives",
                    "Beneficiaries",
                    "Creative Approach",
                    "Financial Resources",
                    "Business Model",
                    "Human Resources",
                    "Entity Types",
                    "Competences",
                    "ICH Domain",
                    "ICH Elements",
                    "Data Source",
                    "Data Type",
                    "Capturing Technologies",
                    "Representation Technologies",
                    "Digitization Output",
                    "Dissemination Technologies",
                    "Fruition Output"
                ]

                // variables for selection
                const property1Select = d3.select("#property-1");
                //const property2Select = d3.select("#property-2");
                const filterSelect = d3.select("#filter-central");

                const dynamicPropertiesContainer = d3.select("#dynamic-properties");
                const addPropertyButton = d3.select("#add-property");
                const removePropertyButton = d3.select("#remove-property");

                function updatePropertiesSelect(selectElement, properties){
                    selectElement.selectAll('myOptions')
                        .data(properties)
                        .enter()
                        /*.join('option')
                        .text(d => d) // text showed in the menu
                        .attr("value", d => d) // corresponding value returned by the button*/
                        .append('option')
                        .text(function (d) {return d;}) // text showed in the menu
                        .attr("value", function (d) {return d; });
                }

                // Populate the select elements with options
                updatePropertiesSelect(property1Select, properties);
                //updatePropertiesSelect(property2Select, second_properties);

                addPropertyButton.on("click", () => {
                        const newIndex = selectedSecondaryProperties.length;
                        if (newIndex >= secondaryColors.length) {
                            alert("Maximum number of properties added.");
                            return;
                    }

                    //manage dynamically new properties
                    const controlGroup = dynamicPropertiesContainer.append("div").attr("class", "control-group");
                    controlGroup.append("label").text(`AND`); //vedi se va bene
                    const newSelect = controlGroup.append("select").attr("id", `property-${newIndex + 2}`);
                    updatePropertiesSelect(newSelect, second_properties);

                    selectedSecondaryProperties.push({ select: newSelect, value: null, color: secondaryColors[newIndex] });

                    newSelect.on("change", function() {
                        const selectedValue = d3.select(this).property("value");
                        selectedSecondaryProperties[newIndex].value = selectedValue;
                        updateVisualization();
                    });
                        
                    removePropertyButton.style("display", "block");
                    updateButtonAndCanvasState();
                    updateVisualization();

                });

                removePropertyButton.on("click", () => {
                    if (selectedSecondaryProperties.length > 0) {
                        dynamicPropertiesContainer.select(".control-group:last-child").remove();
                        selectedSecondaryProperties.pop();
                        updateVisualization();
                    }
                    if (selectedSecondaryProperties.length === 0) {
                        removePropertyButton.style("display", "none");
                    }
                    updateButtonAndCanvasState();
                });

                //filter
                //check the corresponding data in the named column (parsed)
                // display unique values
                //return them to modify the data viz
                //if nothing chosen, display all unique elements in more central nodes.
                 function updateFilterDropdown() {

                    // Use flatMap to iterate over the data, parse the array string from the
                    // selected column, and flatten the resulting arrays into a single array.
                    const allValues = data.flatMap(d => {
                        // Check if the property exists for the row to avoid errors.
                        if (d[selectedProperty1]) {
                            return parseArrayField(d[selectedProperty1]);
                        }
                        return []; // Return an empty array for empty/missing cells.
                    });

                    // Create a unique set of values from the flattened array.
                    const uniqueValues = [...new Set(allValues)].sort();
                    console.log("Unique values found:", uniqueValues);

                    // Clear any previous options from the filter select.
                    filterSelect.html('');

                    // Add "All" to the beginning of the options array.
                    const filterOptions = ["All", ...uniqueValues];

                    // Bind the unique values to new <option> elements.
                    // The .join() method is a modern way to handle enter, update, and exit selections.
                    filterSelect.selectAll('option')
                        .data(filterOptions)
                        .join('option')
                        .text(d => d)
                        .attr('value', d => d);
                }

                /**
                 * Updates the CENTRAL_NODE variable based on the current selections
                 * of the property and filter dropdowns.
                 */
                function updateCentralNodeData() {
                    const selectedFilter = filterSelect.property("value");

                    console.log(`Updating CENTRAL_NODE with Property: '${selectedProperty1}' and Filter: '${selectedFilter}'`);

                    if (selectedFilter === "All") {
                        // If "All" is selected, populate with all unique values from that property column.
                        const allValues = data.flatMap(d => d[selectedProperty1] ? parseArrayField(d[selectedProperty1]) : []);
                        CENTRAL_NODE = [...new Set(allValues)];
                    } else {
                        // If a specific value is selected, just use that value.
                        // Storing it in an array for consistency in your visualization logic.
                        CENTRAL_NODE = [selectedFilter];
                    }
                    console.log("CENTRAL_NODE is now:", CENTRAL_NODE);
                }

                /** --- Visualization Logic --- */
                function updateVisualization() {
                    try {
                        // Get current viewport dimensions
                        const container_element = document.getElementById('node-viz');
                        const width = container_element.clientWidth || 800;
                        const height = container_element.clientHeight || 800;
                        
                        console.log("Viewport dimensions:", width, height);
                        console.log("updating visualisation with: ", {selectedProperty1, CENTRAL_NODE});

                        // ---- 1.CLEAR PREVIOUS VISUALIZATION ---- //
                        container.html(''); // Clear previous visualization
                        
                        // Reset zoom to identity
                        svg.call(zoom.transform, d3.zoomIdentity);

                        if (!CENTRAL_NODE || CENTRAL_NODE.length === 0 || !selectedProperty1) {
                            console.warn("Required properties not set. Aborting visualization update.");
                            return;
                        }

                        // ---- 2.FILTER DATA BASED ON CENTRAL NODE ---- //
                        const centralNodeLowerCase = CENTRAL_NODE.map(c => String(c).toLowerCase());
                        const filteredData = data.filter(d =>
                            d[selectedProperty1] && parseArrayField(d[selectedProperty1]).some(x =>
                                centralNodeLowerCase.includes(String(x).toLowerCase())
                            )
                        );

                        console.log("Filtered rows:", filteredData.length, filteredData.map(d => d.Title));

                        // ---- 3.CREATE NODES AND LINKS ---- //
                        const nodes = [];
                        const links = [];
                        const addedIds = new Set(); //keep track of added node to prevent duplicates

                        // Add central nodes
                        CENTRAL_NODE.forEach(nodeId => {
                            if (!addedIds.has(nodeId)) {
                                nodes.push({ id: nodeId, type: "central", r: 15 });
                                addedIds.add(nodeId);
                            }
                        });

                        //Add project and secondary property nodes
                        filteredData.forEach(d => {
                            const projectID = d.Title;
                            if (!addedIds.has(projectID)) {
                                nodes.push({ id: projectID, type: "project", r: 10 });
                                addedIds.add(projectID);
                            }

                            if (d[selectedProperty1]) {
                                parseArrayField(d[selectedProperty1]).forEach(propValue => {
                                    if (centralNodeLowerCase.includes(String(propValue).toLowerCase())) {
                                        links.push({ source: propValue, target: projectID });
                                    }
                                });
                            }

                            selectedSecondaryProperties.forEach((prop, index) => {
                                if (prop.value && d[prop.value]) {
                                    parseArrayField(d[prop.value]).forEach(propValue => {
                                        const propNodeId = `${propValue}_${index}`;
                                        if (!addedIds.has(propNodeId)) {
                                            nodes.push({ id: propNodeId, name: propValue, type: `second_property_${index}`, r: 8, color: prop.color });
                                            addedIds.add(propNodeId);
                                        }
                                        links.push({ source: projectID, target: propNodeId });
                                    });
                                }
                            });
                        });

                        if (nodes.length === 0) {
                            displayCanvasMessage("No nodes to render.");
                            return;
                        }

                        // ---- 4. SETUP FORCEATLAS2 LAYOUT ---- //

                        // Create a Graphology graph
                        const Graph = graphology.Graph;
                        const graph = new Graph();

                        // Count incoming links for each node to adjust circle size
                        const linkCountMap = new Map();
                        links.forEach(l => {
                            linkCountMap.set(l.source, (linkCountMap.get(l.source) || 0) + 1);
                            linkCountMap.set(l.target, (linkCountMap.get(l.target) || 0) + 1);
                        });

                        const maxLinks = d3.max(Array.from(linkCountMap.values()));

                        const radiusScales = {
                            central: d3.scaleSqrt().domain([1, maxLinks]).range([20, 30]),
                            project: d3.scaleSqrt().domain([1, maxLinks]).range([10, 20])
                        };

                        selectedSecondaryProperties.forEach((prop, index) => {
                            radiusScales[`second_property_${index}`] = d3.scaleSqrt()
                                                                        .domain([1, maxLinks])
                                                                        .range([8, 20]);
                        });

                        // Set the radius for each node based on its link count
                        nodes.forEach(n => {
                            const linkCount = linkCountMap.get(n.id) || 1;
                            const scale = radiusScales[n.type] || d3.scaleSqrt().domain([1, maxLinks]).range([5, 5]);
                            n.r = scale(linkCount);
                            
                            // Add nodes to graphology graph with initial random positions
                            graph.addNode(n.id, {
                                x: Math.random() * width,
                                y: Math.random() * height,
                                type: n.type,
                                r: n.r,
                                name: n.name,
                                color: n.color
                            });
                        });

                        // Add edges to graphology graph
                        links.forEach((l, i) => {
                            try {
                                graph.addEdge(l.source, l.target, { id: `edge-${i}` });
                            } catch (e) {
                                console.warn("Edge already exists or invalid:", l);
                            }
                        });

                        // ForceAtlas2 settings
                        const settings = {
                            settings: {
                                barnesHutOptimize: true,      // Use Barnes-Hut approximation for better performance
                                barnesHutTheta: 0.5,
                                scalingRatio: 30,              // Increased for longer links
                                strongGravityMode: false,
                                gravity: 0.1,                  // Reduced for more spread
                                slowDown: 1,
                                linLogMode: false,             // LinLog mode for clustered graphs
                                outboundAttractionDistribution: false,
                                adjustSizes: true,             // Account for node sizes in the layout
                                edgeWeightInfluence: 0.1       // Reduced for longer links
                            }
                        };

                        // Create animated ForceAtlas2 simulation
                        console.log("Creating ForceAtlas2 simulation...");
                        const simulation = ForceAtlas2.create(graph, settings);
                        
                        // Link nodes array to simulation nodes for position updates
                        nodes.forEach(n => {
                            const simNode = simulation.nodeMap.get(n.id);
                            if (simNode) {
                                n.simNode = simNode;
                            }
                        });

                        console.log("Sample initial positions:", nodes.slice(0, 3).map(n => ({ id: n.id, x: n.simNode?.x, y: n.simNode?.y })));

                        // ---- 5. RENDER VISUALIZATION ---- //

                        const stickyLabels = new Set();

                        /**
                         * Wraps text and dynamically adjusts font size to ensure it fits within the node.
                         * It then perfectly centers the resulting text block vertically.
                         */
                        function wrapText(textSelection) {
                            const initialFontSize = 11; // The starting font size in px
                            const minFontSize = 8;     // The smallest font size we'll allow
                            const lineHeight = 1.1;     // ems

                            textSelection.each(function(d) {
                                if (d.type !== 'central') return;

                                const text = d3.select(this);
                                // Get the original words list once.
                                const originalWords = d.id.split(/\s+/).reverse();
                                const maxDimension = d.r * 2 * 0.85;

                                let currentFontSize = initialFontSize;
                                text.attr("transform", null);

                                while (currentFontSize >= minFontSize) {
                                    text.style("font-size", `${currentFontSize}px`);

                                    // --- BUG FIX HERE ---
                                    // Create a fresh copy of the words for each iteration.
                                    // This prevents the list from being empty on subsequent loops.
                                    let words = [...originalWords];

                                    text.text(null);
                                    let word;
                                    let line = [];
                                    let tspan = text.append("tspan").attr("x", 0);
                                    
                                    // This loop now correctly operates on a full list of words every time.
                                    while (word = words.pop()) {
                                        line.push(word);
                                        tspan.text(line.join(" "));
                                        if (tspan.node().getComputedTextLength() > maxDimension) {
                                            line.pop();
                                            tspan.text(line.join(" "));
                                            line = [word];
                                            tspan = text.append("tspan").attr("x", 0).attr("dy", `${lineHeight}em`).text(word);
                                        }
                                    }

                                    const bbox = text.node().getBBox();
                                    if (bbox.height < maxDimension && bbox.width < maxDimension) {
                                        break;
                                    }

                                    currentFontSize--;
                                }

                                const finalBbox = text.node().getBBox();
                                const yOffset = - (finalBbox.y + (finalBbox.height / 2));
                                // Add a final check to prevent transform with non-finite values
                                if(isFinite(yOffset)) {
                                    text.attr("transform", `translate(0, ${yOffset})`);
                                }
                            });
                        }

                        const link = container.append("g")
                                        .attr("class", "links")
                                        .selectAll("line")
                                        .data(links)
                                        .join("line")
                                        .attr("stroke", COLOR_LINK) 
                                        .attr("stroke-width", d => {
                                            const sourceCount = linkCountMap.get(d.source) || 1;
                                            const targetCount = linkCountMap.get(d.target) || 1;
                                            return 1 + Math.log1p((sourceCount + targetCount) / 2);
                                        })
                                        .attr("x1", d => {
                                            const sourceNode = nodes.find(n => n.id === d.source);
                                            return sourceNode ? sourceNode.x : 0;
                                        })
                                        .attr("y1", d => {
                                            const sourceNode = nodes.find(n => n.id === d.source);
                                            return sourceNode ? sourceNode.y : 0;
                                        })
                                        .attr("x2", d => {
                                            const targetNode = nodes.find(n => n.id === d.target);
                                            return targetNode ? targetNode.x : 0;
                                        })
                                        .attr("y2", d => {
                                            const targetNode = nodes.find(n => n.id === d.target);
                                            return targetNode ? targetNode.y : 0;
                                        });

                        const node = container.append("g")
                                        .attr("class", "nodes")
                                        .selectAll("g")
                                        .data(nodes)
                                        .join("g")
                                        .attr("class", "node")
                                        .attr("transform", d => `translate(${d.x},${d.y})`);
                        
                        node.append("circle")
                            .attr("r", d => d.r)
                            .attr("fill", d => {
                                if (d.type === 'central') return COLOR_REPO_MAIN;
                                if (d.type === 'project') return COLOR_PROJECT;
                                return d.color || COLOR_OWNER;
                            })

                        node.append("circle")
                            .attr("class", "node-ring")
                            .attr("r", d => d.r + 4)
                            .attr("fill", "none")
                            .attr("stroke", COLOR_REPO_MAIN)
                            .attr("stroke-width", 2)
                            .attr("visibility", "hidden");
                        
                        const labels = node.append("text")
                            .text(d => d.name || d.id)
                            .attr("class", "node-label")
                            .attr("text-anchor", "middle")
                            .attr("dy", d => d.type === "central" ? "0" : `-${d.r +5}px`)
                            .style("font-size", d => (d.type === 'central' ? '15px' : '10px'))
                            .style("font-weight", d => (d.type === 'central' ? 'bold' : 'light'))
                            .style("fill", d => (d.type === 'central' ? 'white' : COLOR_TEXT))
                            .style("font-family", d => { 
                                if (d.type === 'central' || d.type === 'project') return 'Inter, serif';
                                return 'Inter, sans-serif';
                            })
                            .style("pointer-events", "none")
                            .attr("visibility", d => (d.type === 'central' || d.type === 'project') ? 'visible' : 'hidden');

                        labels.call(wrapText); // Apply text wrapping to labels

                        // Helper function to update all visual highlights
                        function updateHighlights(hoveredNode = null) {
                            const activeIds = new Set(stickyLabels);
                            if (hoveredNode) activeIds.add(hoveredNode.id);

                            node.selectAll(".node-ring").attr("visibility", d => activeIds.has(d.id) ? "visible" : "hidden");

                            labels.attr("visibility", d => activeIds.has(d.id) || d.type === 'central' || d.type === 'project' ? 'visible' : 'hidden');

                            link
                                .attr("stroke", l => {
                                    const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                                    const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                                    return activeIds.has(sourceId) || activeIds.has(targetId) ? "#999" : COLOR_LINK;
                                })
                                .attr("stroke-width", l => {
                                    const sourceId = typeof l.source === 'object' ? l.source.id : l.source;
                                    const targetId = typeof l.target === 'object' ? l.target.id : l.target;
                                    return activeIds.has(sourceId) || activeIds.has(targetId) ? 2 : 1.5;
                                });
                        }

                        node
                            .on("mouseenter", (event, d) => updateHighlights(d))
                            .on("mouseleave", () => updateHighlights(null))
                            .on("click", (event, d) => {
                                event.stopPropagation();
                                stickyLabels.has(d.id) ? stickyLabels.delete(d.id) : stickyLabels.add(d.id);
                                updateHighlights(null);
                            });

                        // Make nodes have grab cursor
                        node.style("cursor", "grab");

                        // Add simulation tick function for animation
                        simulation.on = function(event, callback) {
                            if (event === "tick") {
                                this.tickCallback = callback;
                            }
                            return this;
                        };

                        function tick() {
                            // Run one iteration of ForceAtlas2
                            simulation.tick();
                            
                            // Update node positions from simulation
                            nodes.forEach(n => {
                                if (n.simNode) {
                                    n.x = n.simNode.x;
                                    n.y = n.simNode.y;
                                }
                            });
                            
                            // Update visual positions
                            link
                                .attr("x1", d => {
                                    const sourceNode = nodes.find(n => n.id === d.source);
                                    return sourceNode ? sourceNode.x : 0;
                                })
                                .attr("y1", d => {
                                    const sourceNode = nodes.find(n => n.id === d.source);
                                    return sourceNode ? sourceNode.y : 0;
                                })
                                .attr("x2", d => {
                                    const targetNode = nodes.find(n => n.id === d.target);
                                    return targetNode ? targetNode.x : 0;
                                })
                                .attr("y2", d => {
                                    const targetNode = nodes.find(n => n.id === d.target);
                                    return targetNode ? targetNode.y : 0;
                                });
                            
                            node.attr("transform", d => `translate(${d.x},${d.y})`);
                            
                            // Continue animation if simulation is still running
                            if (simulation.alpha > 0.01) {
                                requestAnimationFrame(tick);
                            }
                        }
                        
                        // Update drag behavior to work with simulation
                        node.call(d3.drag()
                            .on("start", function(event, d) {
                                if (!event.active) simulation.alphaTarget(0.3).restart();
                                d3.select(this).raise();
                                d3.select(this).style("cursor", "grabbing");
                                if (d.simNode) {
                                    d.simNode.fx = d.simNode.x;
                                    d.simNode.fy = d.simNode.y;
                                }
                            })
                            .on("drag", function(event, d) {
                                if (d.simNode) {
                                    d.simNode.fx = event.x;
                                    d.simNode.fy = event.y;
                                    d.simNode.x = event.x;
                                    d.simNode.y = event.y;
                                }
                                d.x = event.x;
                                d.y = event.y;
                                d3.select(this).attr("transform", `translate(${d.x},${d.y})`);
                                
                                // Update connected links
                                link.each(function(l) {
                                    const linkEl = d3.select(this);
                                    if (l.source === d.id) {
                                        linkEl.attr("x1", d.x).attr("y1", d.y);
                                    }
                                    if (l.target === d.id) {
                                        linkEl.attr("x2", d.x).attr("y2", d.y);
                                    }
                                });
                            })
                            .on("end", function(event, d) {
                                if (!event.active) simulation.alphaTarget(0);
                                d3.select(this).style("cursor", "grab");
                                if (d.simNode) {
                                    d.simNode.fx = null;
                                    d.simNode.fy = null;
                                }
                            }));
                        
                        // Start the simulation
                        simulation.start();
                        tick();

                        console.log("ForceAtlas2 simulation started!");


                    } catch (error) {
                        console.error("An error occurred during visualization:", error);
                        displayCanvasMessage(`No correlations available: ${error.message}`);
                    }
                }

                function updateButtonAndCanvasState() {
                    const updateButton = d3.select("#update");
                    if (selectedSecondaryProperties.length === 0) {
                        updateButton.property("disabled", true);
                        displayCanvasMessage("Please add another property to compare");
                    } else {
                        updateButton.property("disabled", false);
                        container.html(''); // Clear the message
                    }
                }

                /* --- EVENT LISTENERS --- */
                function handleProperty1Change() {
                    selectedProperty1 = property1Select.property("value");
                    updateFilterDropdown();
                    updateCentralNodeData();
                }

                property1Select.on("change", handleProperty1Change);
                filterSelect.on("change", updateCentralNodeData);

                // Link the update button to the main visualization function.
                d3.select("#update").on("click", updateVisualization);

                /* --- INITIALIZATION --- */
                // Set the initial state when the page loads.
                handleProperty1Change();
                updateButtonAndCanvasState();
            
            }).catch(error => {
                console.error('Error loading CSV:', error);
                displayCanvasMessage(`Error loading data: ${error.message}`);
            });
        </script>
    </body>
</html>